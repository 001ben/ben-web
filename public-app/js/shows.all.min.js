(function () {
    'use strict';

    // Prepare the 'shows' module for subsequent registration of controllers and delegates
    angular.module('shows', ['ngMaterial', 'ngMessages', 'iconSelector'])
        .config(['$mdThemingProvider', '$mdIconProvider', 'extendDefaultObjectsProvider', ConfigurationLogic])
        .run(['cseRenderer', InitialisationLogic]);

    function ConfigurationLogic($mdThemingProvider, $mdIconProvider, extendDefaultObjectsProvider) {
        $mdIconProvider
            .defaultIconSet("./assets/svg/avatars.svg", 128)
            .icon("menu", "./assets/svg/menu.svg", 24)
            .icon("share", "./assets/svg/share.svg", 24)
            .icon("google_plus", "./assets/svg/google_plus.svg", 512)
            .icon("hangouts", "./assets/svg/hangouts.svg", 512)
            .icon("twitter", "./assets/svg/twitter.svg", 512)
            .icon("phone", "./assets/svg/phone.svg", 512);

        $mdThemingProvider
            .theme('default')
            .primaryPalette('blue-grey')
            .accentPalette('blue');

        extendDefaultObjectsProvider
            .objectFor('show-image', {
                'background-size': 'cover',
                'background-position': '50% 50%',
                'background-repeat': 'no-repeat'
            });
    }

    function InitialisationLogic(cseRenderer) {
        cseRenderer.initialise();
        
        $('.avatar-container').hover(function() {
            $('.avatar-image').addClass('image-hover')
            $('.add-image').addClass('image-hover');
        }, function() {
            $('.avatar-image').removeClass('image-hover')
            $('.add-image').removeClass('image-hover');
        });
    }
})();
(function () {

    angular.module('shows').constant('showType', {
        episodes: 'episodes',
        seasons: 'seasons',
        movie: 'movie'
    });

})();
(function () {

    angular.module('shows')
        .controller('showController', ['showData', 'showSaver', 'showType', 'iconSelectorService', '$mdSidenav', '$log', '$q', ShowController]);

    function ShowController(showData, showSaver, showType, iconSelectorService, $mdSidenav, $log, $q) {
        var self = this;

        self.selected = {
            name: ' '
        };
        
        self.showType = showType;
        self.shows = [];
        self.selectShow = selectShow;
        self.toggleList = toggleShowsList;
        self.addShow = addShow;
        self.loading = true;
        self.openIconSelector = iconSelectorService.getShowSelector(handleDialogResponse, getSelectedShowName, getSelectedShowId, showData.uploadImage);

        // Load all registered shows
        showData
            .loadAllShows()
            .success(function (shows) {
                self.shows = [].concat(shows);
                self.selected = shows[0];
                self.loading = false;
                initSaver();
            });

        // *********************************
        // Internal methods
        // *********************************

        /**
         * First hide the bottomsheet IF visible, then
         * hide or Show the 'left' sideNav area
         */
        function getSelectedShowName() {
            return self.selected.name;
        }
        
        function getSelectedShowId() {
            return self.selected._id;
        }
        
        function toggleShowsList() {
            $mdSidenav('left').toggle();
        }

        function selectShow(show) {
            if (self.showForm.$invalid || !showSaver.storeCurrent())
                return;

            self.selected = angular.isNumber(show) ? $scope.shows[show] : show;
            self.toggleList();
            initSaver();
        }

        function initSaver(isNew) {
            var funcName = 'init' + (!isNew ? 'Show' : 'New');
            showSaver[funcName](self.showForm, self.selected);
            
            self.showForm.$setPristine();
            self.showForm.$setUntouched();
        }

        function addShow() {
            if (!showSaver.storeCurrent())
                return;
            
            var newShow = { };
            
            self.shows.unshift(newShow);
            self.selected = newShow;
            initSaver(true);
        }
        
        function handleDialogResponse(data) {
            if(data.hasNewImage) {
                self.selected.image = data.newImageProperties;
            }
        }
    }
})();
(function () {
    'use strict';

    angular.module('shows').service('showData', ['$q', '$http', ShowService]);

    // Service just maps object methods to api urls
    function ShowService($q, $http) {
        
        // Methods return http promises. 
        return {
            loadAllShows: function () {
                return $http.get('/shows');
            },
            updateShow: function(showId, showObj) {
                return $http.post('/shows/update/' + showId, showObj);
            },
            createShow: function(showObj) {
                return $http.post('/shows/create', showObj);
            },
            uploadImage: function(showId, imageProperties) {
                return $http.post('shows/image/' + showId, imageProperties);
            }
        };
    }
})();
(function() {
angular.module('shows').directive('benEditable', ['$mdMedia', BenEditable]);

function BenEditable($mdMedia) {
    return {
        restrict: 'A',
        require: 'ngModel',
        transclude: true,
        template: '<div><span contenteditable tabindex="{{tabindex}}" ng-style="style" data-ph="{{placeholder}}"></span></div><ng-transclude></ng-transclude>',
        scope: {
            modelValue: '=ngModel',
            tabindex: '=',
            placeholder: '@'
        },
        link: function (scope, element, attrs, ngModel) {
            var inlineSpan = angular.element(element.children()[0].childNodes[0]);

            scope.isEmpty = false;
            scope.style = {};

            function updateTextStyle(text) {
                if (scope.isEmpty != (!text)) {
                    scope.isEmpty = !scope.isEmpty;

                    if (scope.isEmpty) {
                        scope.style = {
                            display: 'inline-block',
                            width: $mdMedia('sm') ? '80%' : '200px'
                        };
                    } else {
                        scope.style = {};
                    }
                }
            }

            function read() {
                var text = inlineSpan.text();
                updateTextStyle(text);
                ngModel.$setViewValue(text);
            }

            function write() {
                var text = ngModel.$viewValue || '';
                updateTextStyle(text);
                inlineSpan.text(text);
            }

            ngModel.$render = write;

            inlineSpan.bind('blur keyup change', function () {
                if (!scope.$$phase) {
                    scope.$apply(read);
                } else {
                    read();
                }
            });
        }
    };
}
})();
(function () {
    'use strict';

    angular.module('shows')
        .provider('extendDefaultObjects', ExtendDefaultObjects)
        .filter('extendDefault', ['extendDefaultObjects', ExtendDefaultFilter]);

    function ExtendDefaultObjects() {
        var defaults = [];

        return {
            objectFor: function (name, object) {
                defaults.push([name, object]);
                return this;
            },
            $get: function () {
                return {
                    getObjectFor: function (name) {
                        for (var i = 0; i < defaults.length; i++) {
                            if (defaults[i][0] == name) {
                                return defaults[i][1];
                            }
                        }
                    },
                    extendObject: function (name, object) {
                        var defaultValue = this.getObjectFor(name);
                        return angular.extend({}, defaultValue, object);
                    }
                };
            }
        };
    };

    function ExtendDefaultFilter(extendDefaultObjects) {
        return function (input, name) {
            return extendDefaultObjects.extendObject(name, input);
        };
    };
})();
(function () {
    'use strict';

    angular.module('shows').service('showSaver', ['showData', '$interval', '$log', '$rootScope', ShowSaver]);

    var saverDebounceRate = 1000,
        retries = 5;

    // Service just maps object methods to api urls
    function ShowSaver(showData, $interval, $log, $rootScope) {

        var currentId,
            currentForm,
            currentShowObject,
            currentModels,
            debouncer = {},
            storedModelObjects = {};

        function cancelSaver(showId) {
            showId = showId || currentId;

            if (!debouncer[showId])
                return;
            else if (debouncer[showId].$$state.status || $interval.cancel(debouncer[showId]))
                debouncer[showId] = null;
            else
                $log.error('Could not cancel showId: ' + showId);
        }

        function startSaver(showId, showObject, retryCount) {
            showId = showId || currentId;
            showObject = showObject || currentShowObject;
            retryCount = retryCount || 0;

            cancelSaver(showId);
            debouncer[showId] = $interval(attemptSave, saverDebounceRate, 1, true, showId, showObject, retryCount);
        }

        function copyChangedFields(models, showObject) {
            var copyObject = {},
                atLeastOneProperty = false;

            for (var m in models) {
                if (models[m].$dirty) {
                    if (models[m].$invalid) {
                        $log.error('Should not call copyChangedFields on invalid form');
                        return null;
                    }

                    atLeastOneProperty = true;
                    copyObject[m] = showObject[m];
                }
            }

            if (atLeastOneProperty)
                return copyObject;
            else
                $log.error('All model objects are pristine');
        }

        function attemptSave(saveId, saveObject, retryCount) {
            var submitObject = null;
            debouncer[saveId] = null;

            // This block handles case that we've switched shows and saving is occurring
            // We're assuming that the stored model object has changes and is valid (check before saving it). Will log error if not.
            if (storedModelObjects[saveId]) {
                submitObject = copyChangedFields(storedModelObjects[saveId], saveObject);

                if (!submitObject) {
                    $log.error('An invalid object was saved');
                }
            }
            // This block handles the case that we're saving the current show
            else if (saveId == currentId && currentForm.$dirty && currentForm.$valid) {
                submitObject = copyChangedFields(currentModels, saveObject);

                if (submitObject) {
                    // Clear form as we'll set all submitted fields to dirty if there is an error
                    currentForm.$setPristine();
                    currentForm.$setUntouched();
                }
            }

            if (!submitObject)
                return;
            else if (saveId === newId)
                doCreate(submitObject, retryCount);
            else
                doUpdate(saveId, submitObject, retryCount);
        }

        function doCreate(show, retryCount) {
            showData.createShow(show)
                .success(function (id) {
                    currentShowObject._id = id;
                    currentId = id;
                }).error(handleError(newId, show, retryCount));
        }

        function doUpdate(saveId, show, retryCount) {
            showData.updateShow(saveId, show)
                .success(function () {
                    if (storedModelObjects[saveId]) {
                        storedModelObjects[saveId] = null;
                    }
                })
                .error(handleError(saveId, show, retryCount));
        }

        function handleError(saveId, show, retryCount) {
            return function (err) {
                $log.info(err);

                // Make all fields dirty if still on current so resubmission is successful    
                if (currentId == saveId) {
                    for (var m in show) {
                        currentModels[m].$setDirty(true);
                        currentModels[m].$setTouched(true);
                        currentModels[m].$validate();
                    }
                }

                if (err.validationFailed === true)
                    cancelSaver(saveId);
                else if (retryCount < (retries - 1))
                    startSaver(saveId, show, retryCount + 1);
                else
                    $log.error('Attempted to save ' + retries + ' times unsuccessfully', err);
            }
        }

        function storeCurrent() {
            if (!currentId || !currentModels) {
                $log.error("Tried saving current before initialisation");
                return false;
            } else if (currentId == newId)
                return false;
            else if (debouncer[currentId]) {
                if (currentForm.$pristine) {
                    cancelSaver(currentId);
                } else if (currentForm.$invalid) {
                    return false;
                } else {
                    var obj = {};

                    for (var m in currentModels) {
                        obj[m] = {
                            $dirty: currentModels[m].$dirty,
                            $valid: currentModels[m].$valid
                        };
                    }

                    storedModelObjects[currentId] = obj;
                }
            }

            return true;
        }

        function clearAll() {
            for (var id in debouncer) {
                cancelSaver(id);
            }
            for (var id in storedModelObjects) {
                storedModelObjects[id] = null;
            }

            currentId = null;
            currentForm = null;
            currentShowObject = null;
            currentModels = null;
        }

        var watches = [];

        function watchCurrentShowObjectChanges() {
            while (watches.length > 0) {
                watches.pop()();
            }

            for (var p in currentForm) {
                if (p[0] != '$') {
                    currentModels[p] = currentForm[p];

                    watches.push($rootScope.$watch(
                        function (showProperty) {
                            return function () {
                                return currentShowObject[showProperty];
                            };
                        }(p),
                        function (newVal, oldVal) {
                            startSaver();
                        }
                    ));
                }
            }
        };

        function initialise(form, show) {
            if (currentForm && currentForm.$invalid) {
                $log.error('attempted initialising while current form invalid');
                return;
            }

            currentForm = form;
            currentShowObject = show;
            currentModels = {};

            watchCurrentShowObjectChanges();
        }

        function initialiseShow(form, show) {
            currentId = show._id;
            initialise(form, show);
        }

        var newId = 'newId';

        function initialiseNew(form, show) {
            if (currentId == newId) {
                $log.error('attempted to initialise a new show before previous new show was saved');
                return;
            }

            currentId = newId;
            initialise(form, show);
        }

        return {
            initShow: initialiseShow,
            initNew: initialiseNew,
            storeCurrent: storeCurrent,
            clearAll: clearAll
        };
    }
})();
//# sourceMappingURL=../maps/shows.all.min.js.map