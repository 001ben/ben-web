(function() {
  var ConfigurationLogic, InitialisationLogic;

  ConfigurationLogic = function($mdThemingProvider, $mdIconProvider, extendDefaultObjectsProvider) {
    $mdIconProvider.defaultIconSet("./assets/svg/avatars.svg", 128).icon("menu", "./assets/svg/menu.svg", 24).icon("share", "./assets/svg/share.svg", 24).icon("google_plus", "./assets/svg/google_plus.svg", 512).icon("hangouts", "./assets/svg/hangouts.svg", 512).icon("twitter", "./assets/svg/twitter.svg", 512).icon("phone", "./assets/svg/phone.svg", 512);
    $mdThemingProvider.theme('default').primaryPalette('blue-grey').accentPalette('blue');
    extendDefaultObjectsProvider.objectFor('show-image', {
      'background-size': 'cover',
      'background-position': '50% 50%',
      'background-repeat': 'no-repeat'
    });
  };

  InitialisationLogic = function(cseRenderer) {
    cseRenderer.initialise();
    $('.avatar-container').hover(function() {
      $('.avatar-image').addClass('image-hover');
      $('.add-image').addClass('image-hover');
    }, function() {
      $('.avatar-image').removeClass('image-hover');
      $('.add-image').removeClass('image-hover');
    });
  };

  angular.module('shows', ['ngMaterial', 'ngMessages', 'iconSelector']).config(['$mdThemingProvider', '$mdIconProvider', 'extendDefaultObjectsProvider', ConfigurationLogic]).run(['cseRenderer', InitialisationLogic]);

}).call(this);

(function() {
  angular.module('shows').constant('showType', {
    episodes: 'episodes',
    seasons: 'seasons',
    movie: 'movie'
  });

}).call(this);

(function() {
  var ShowController;

  ShowController = function(showData, showSaver, showType, iconSelectorService, $mdSidenav, $log, $q) {
    var initSaver, self;
    self = this;
    this.shows = [];
    this.loading = true;
    this.showType = showType;
    this.selected = {
      name: ' '
    };
    showData.loadAllShows().success(function(shows) {
      self.shows = [].concat(shows);
      self.selected = shows[0];
      self.loading = false;
      initSaver();
    });

    /*
    	 Controller methods
     */
    this.toggleShowsList = function() {
      $mdSidenav('left').toggle();
    };
    this.selectShow = function(show) {
      if (self.showForm.$invalid || !showSaver.storeCurrent()) {
        return;
      }
      self.selected = angular.isNumber(show) ? $scope.shows[show] : show;
      self.toggleShowsList();
      initSaver();
    };
    this.addShow = function() {
      var newShow;
      if (!showSaver.storeCurrent()) {
        return;
      }
      newShow = {};
      self.shows.unshift(newShow);
      self.selected = newShow;
      initSaver(true);
    };
    this.openIconSelector = iconSelectorService.getShowSelector(function(data) {
      if (data.hasNewImage) {
        self.selected.image = data.newImageProperties;
      }
    }, function() {
      return self.selected.name;
    }, function() {
      return self.selected._id;
    }, showData.uploadImage);

    /*
    	 Internal methods
     */
    initSaver = function(isNew) {
      var funcName;
      funcName = 'init' + (isNew ? 'New' : 'Show');
      showSaver[funcName](self.showForm, self.selected);
      self.showForm.$setPristine();
      self.showForm.$setUntouched();
    };
  };

  angular.module('shows').controller('showController', ['showData', 'showSaver', 'showType', 'iconSelectorService', '$mdSidenav', '$log', '$q', ShowController]);

}).call(this);

(function() {
  var ShowService;

  ShowService = function($q, $http) {
    return {
      loadAllShows: function() {
        return $http.get('/shows');
      },
      updateShow: function(showId, showObj) {
        return $http.post('/shows/update/' + showId, showObj);
      },
      createShow: function(showObj) {
        return $http.post('/shows/create', showObj);
      },
      uploadImage: function(showId, imageProperties) {
        return $http.post('shows/image/' + showId, imageProperties);
      }
    };
  };

  angular.module('shows').service('showData', ['$q', '$http', ShowService]);

}).call(this);

(function() {
  var BenEditable;

  BenEditable = function($mdMedia) {
    return {
      restrict: 'A',
      require: 'ngModel',
      transclude: true,
      template: '<div><span contenteditable ng-style="style" data-ph="{{placeholder}}"></span></div><ng-transclude></ng-transclude>',
      scope: {
        modelValue: '=ngModel',
        tabindex: '=',
        placeholder: '@'
      },
      link: function(scope, element, attrs, ngModel) {
        var inlineSpan, read, updateTextStyle;
        inlineSpan = angular.element(element.children()[0].childNodes[0]);
        scope.isEmpty = false;
        scope.style = {};
        updateTextStyle = function(text) {
          if (scope.isEmpty !== (!text)) {
            scope.isEmpty = !scope.isEmpty;
            if (scope.isEmpty) {
              scope.style = {
                display: 'inline-block',
                width: $mdMedia('sm') ? '80%' : '200px'
              };
            } else {
              scope.style = {};
            }
          }
        };
        read = function() {
          var text;
          text = inlineSpan.text();
          updateTextStyle(text);
          ngModel.$setViewValue(text);
        };
        ngModel.$render = function() {
          var text;
          text = ngModel.$viewValue || '';
          updateTextStyle(text);
          inlineSpan.text(text);
        };
        inlineSpan.bind('blur keyup change', function() {
          if (scope.$$phase != null) {
            read();
          } else {
            scope.$apply(read);
          }
        });
      }
    };
  };

  angular.module('shows').directive('benEditable', ['$mdMedia', BenEditable]);

}).call(this);

(function() {
  var ExtendDefaultFilter, ExtendDefaultObjects;

  ExtendDefaultObjects = function() {
    var defaults;
    defaults = {};
    return {
      objectFor: function(name, object) {
        defaults[name] = object;
        return this;
      },
      $get: function() {
        return {
          getObjectFor: function(name) {
            var obj, objName;
            for (objName in defaults) {
              obj = defaults[objName];
              if (objName === name) {
                return obj;
              }
            }
          },
          extendObject: function(name, object) {
            return angular.extend({}, this.getObjectFor(name), object);
          }
        };
      }
    };
  };

  ExtendDefaultFilter = function(extendDefaultObjects) {
    return function(input, name) {
      return extendDefaultObjects.extendObject(name, input);
    };
  };

  angular.module('shows').provider('extendDefaultObjects', ExtendDefaultObjects).filter('extendDefault', ['extendDefaultObjects', ExtendDefaultFilter]);

}).call(this);

(function() {
  var ShowSaver, retries, saverDebounceRate;

  saverDebounceRate = 1000;

  retries = 5;

  ShowSaver = function(showData, $interval, $log, $rootScope) {
    var attemptSave, cancelSaver, clearAll, copyChangedFields, currentForm, currentId, currentModels, currentShowObject, debouncer, doCreate, doUpdate, handleError, initialise, initialiseNew, initialiseShow, newId, startSaver, storeCurrent, storedModelObjects, watchCurrentShowObjectChanges, watches;
    currentId = currentForm = currentShowObject = currentModels = null;
    newId = 'newId';
    debouncer = {};
    storedModelObjects = {};
    watches = [];
    cancelSaver = function(showId) {
      if (showId == null) {
        showId = currentId;
      }
      if (!debouncer[showId]) {
        return;
      } else if (debouncer[showId].$$state.status || $interval.cancel(debouncer[showId])) {
        debouncer[showId] = null;
      } else {
        $log.error("Could not cancel showId: " + showId);
      }
    };

    /*
    	 FUNCTION Starts the show saver countdown for given show id. After interval, saver checks validation and $dirty status then saves if it can
     */
    startSaver = function(showId, showObject, retryCount) {
      if (showId == null) {
        showId = currentId;
      }
      if (showObject == null) {
        showObject = currentShowObject;
      }
      if (retryCount == null) {
        retryCount = 0;
      }
      cancelSaver(showId);
      debouncer[showId] = $interval(attemptSave, saverDebounceRate, 1, true, showId, showObject, retryCount);
    };
    copyChangedFields = function(models, showObject) {
      var atLeastOneProperty, copyObject, m, mName;
      copyObject = {};
      atLeastOneProperty = false;
      for (mName in models) {
        m = models[mName];
        if (!m.$dirty) {
          continue;
        }
        if (m.$invalid) {
          $log.error('Should not call copyChangedFields on invalid form');
          return null;
        }
        atLeastOneProperty = true;
        copyObject[mName] = showObject[mName];
      }
      if (atLeastOneProperty) {
        return copyObject;
      } else {
        $log.error('All model objects are pristine');
      }
    };

    /*
    	 FUNCTION Attempts to save show corresponding to given saveId (callback for startSaver)
     */
    attemptSave = function(saveId, saveObject, retryCount) {
      var submitObject;
      submitObject = null;
      debouncer[saveId] = null;
      if (storedModelObjects[saveId] != null) {
        submitObject = copyChangedFields(storedModelObjects[saveId], saveObject);
        if (!submitObject) {
          $log.error('An invalid object was saved');
        }
      } else if (saveId === currentId && currentForm.$dirty && currentForm.$valid) {
        submitObject = copyChangedFields(currentModels, saveObject);
        if (submitObject != null) {
          currentForm.$setPristine();
          currentForm.$setUntouched();
        }
      }
      if (!submitObject) {
        return;
      } else if (saveId === newId) {
        doCreate(submitObject, retryCount);
      } else {
        doUpdate(saveId, submitObject, retryCount);
      }
    };
    doCreate = function(show, retryCount) {
      showData.createShow(show).success(function(id) {
        return currentShowObject._id = currentId = id;
      }).error(handleError(newId, show, retryCount));
    };
    doUpdate = function(saveId, show, retryCount) {
      return showData.updateShow(saveId, show).success(function() {
        if (storedModelObjects[saveId]) {
          storedModelObjects[saveId] = null;
        }
      }).error(handleError(saveId, show, retryCount));
    };
    handleError = function(saveId, show, retryCount) {
      return function(err) {
        var fieldName;
        $log.info(err);
        if (currentId === saveId) {
          for (fieldName in show) {
            currentModels[fieldName].$setDirty(true);
            currentModels[fieldName].$setTouched(true);
            currentModels[fieldName].$validate();
          }
        }
        if (err.validationFailed === true) {
          cancelSaver(saveId);
        } else if (retryCount < (retries - 1)) {
          startSaver(saveId, show, retryCount + 1);
        } else {
          $log.error("Attempted to save " + retries + " times unsuccessfully", err);
        }
      };
    };
    storeCurrent = function() {
      var m, mName, obj;
      if (!currentId || !currentModels) {
        $log.error('Tried saving current before initialisation');
        return false;
      } else if (currentId === newId) {
        return false;
      } else if (debouncer[currentId] != null) {
        if (currentForm.$pristine) {
          cancelSaver(currentId);
        } else if (currentForm.$invalid) {
          return false;
        } else {
          obj = {};
          for (mName in currentModels) {
            m = currentModels[mName];
            obj[mName] = {
              $dirty: m.$dirty,
              $valid: m.$valid
            };
          }
          storedModelObjects[currentId] = obj;
        }
      }
      return true;
    };
    clearAll = function() {
      var id;
      for (id in debouncer) {
        cancelSaver(id);
      }
      for (id in storedModelObjects) {
        storedModelObjects[id] = null;
      }
      currentId = currentForm = currentShowObject = currentModels = null;
    };
    watchCurrentShowObjectChanges = function() {
      var p;
      while (watches.length !== 0) {
        watches.pop()();
      }
      for (p in currentForm) {
        if (!(p[0] !== '$')) {
          continue;
        }
        currentModels[p] = currentForm[p];
        watches.push($rootScope.$watch((function(p) {
          return function() {
            return currentShowObject[p];
          };
        })(p), function() {
          startSaver();
        }));
      }
    };
    initialise = function(form, show) {
      if ((currentForm != null) && currentForm.$invalid) {
        $log.error('attempted initialising while current form invalid');
        return;
      }
      currentForm = form;
      currentShowObject = show;
      currentModels = {};
      watchCurrentShowObjectChanges();
    };
    initialiseShow = function(form, show) {
      currentId = show._id;
      initialise(form, show);
    };
    initialiseNew = function(form, show) {
      if (currentId === newId) {
        $log.error('attempted to initialise a new show before previous new show was saved');
        return;
      }
      currentId = newId;
      initialise(form, show);
    };
    return {
      initShow: initialiseShow,
      initNew: initialiseNew,
      storeCurrent: storeCurrent,
      clearAll: clearAll
    };
  };

  angular.module('shows').service('showSaver', ['showData', '$interval', '$log', '$rootScope', ShowSaver]);

}).call(this);

//# sourceMappingURL=../../maps/shows.all.min.js.map